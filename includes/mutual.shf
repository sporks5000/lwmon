#! /bin/bash

function fn_debug {
### if $b_DEBUG is true, this will cause every function to output its name every time it is run, and any other time fn_debug is called
### If $b_DEBUG2 is true, this will only output if the data it's passed does not begin with "fn_"
	if [[ "$b_DEBUG" == true ]]; then
		echo "$$ - $v_RUNNING_STATE: '$1'" > /dev/stderr
	elif [[ "$b_DEBUG2" == true && "${1:0:3}" != "fn_" ]]; then
		echo "$$ - $v_RUNNING_STATE: '$1'" > /dev/stderr
	fi
}

function fn_fix_home {
### This function ensures that if a file begins with "~/" The file name is expanded appropriately.
### It expects $1 to be the name of a file
	fn_debug "fn_fn_fix_home"
	local v_RESULT="$1"
	if [[ "${v_RESULT:0:2}" == "~/" && -n "$HOME" ]]; then
		v_RESULT="$HOME""${v_RESULT:1}"
	elif [[ "${v_RESULT:0:2}" == "~/" ]]; then
		echo "No \$HOME variable set. Cannot correct paths beginning with \"~/\"." > /dev/stderr
		exit 1
	fi
	echo "$v_RESULT"
}

function fn_update_conf {
### This function updates a value in the conf file. It expects $1 to be the name of the directive, $2 to be the new value for that directive, and $3 to be the name of the conf file.
	fn_debug "fn_update_conf"
	if [[ "$3" == "child" && -f "$d_WORKING"/"$v_CHILD_PID"/params ]]; then
		v_CONF_FILE="$d_WORKING"/"$v_CHILD_PID"/params
	elif [[ "$3" == "master" && -f "$f_CONF" ]]; then
		v_CONF_FILE="$f_CONF"
	else
		v_CONF_FILE="$3"
	fi
	if [[ -f "$v_CONF_FILE" ]]; then
		### We're about to run $2 through sed, so it needs to have all of its slashes escaped.
		v_MODIFIED_2="$( echo "$2" | sed -e 's/[\/&]/\\&/g' )"
		if [[ $( grep -E -c "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*" "$v_CONF_FILE" 2> /dev/null ) -gt 0 ]]; then
			sed -i "$( grep -E -n "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*" "$v_CONF_FILE" | tail -n1 | cut -d ":" -f1 )""s/\(^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*\).*$/\1""$v_MODIFIED_2/" "$v_CONF_FILE"
		elif [[ $( grep -E -c "^[[:blank:]]*##*[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*$" "$v_CONF_FILE" 2> /dev/null ) -gt 0 ]]; then
		### If there's a commended-out line, but it doesn't have a value afterward...
			sed -i "$( grep -E -n "^[[:blank:]]*##*[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*" "$v_CONF_FILE" | tail -n1 | cut -d ":" -f1 )""s/^[[:blank:]]*##*\([[:blank:]]*$1[[:blank:]]*=[[:blank:]]*\).*$/\1""$v_MODIFIED_2/" "$v_CONF_FILE"
		else
			echo "$1 = $v_MODIFIED_2" >> "$v_CONF_FILE"
		fi
	fi
}

function fn_test_file {
### This function expects $1 to be the path to a file, $2 to be true or false whether the file needs to be tested for read permission, and $3 to be true or false whether the file needs to be tested for write permission.
	fn_debug "fn_test_file"
	v_RESULT="$1"
	if [[ -n "$v_RESULT" ]]; then 
		if [[ -n "$HOME" && "${v_RESULT:0:2}" == "~/" ]]; then
			v_RESULT="$HOME""${v_RESULT:1}"
		fi
		if [[ ${v_RESULT:0:1} == "/" && "$3" == true && "$2" != true ]]; then
			touch "$v_RESULT" 2> /dev/null
			v_STATUS="$?"
			if [[ ! -e "$v_RESULT" || ! -w "$v_RESULT" || "$v_STATUS" == 1 ]]; then
				unset v_RESULT
			fi
		elif [[ "${v_RESULT:0:1}" == "/" && "$3" != true && "$2" == true ]]; then
			tail -n1 "$v_RESULT" 2> /dev/null
			v_STATUS="$?"
			if [[ ! -e "$v_RESULT" || ! -r "$v_RESULT" || "$v_STATUS" == 1 ]]; then
				unset v_RESULT
			fi
		elif [[ "${v_RESULT:0:1}" == "/" && "$3" == true && "$2" == true ]]; then
			touch "$v_RESULT" 2> /dev/null
			v_STATUS="$?"
			if [[ ! -e "$v_RESULT" || ! -w "$v_RESULT" || "$v_STATUS" == 1 ]]; then
				unset v_RESULT
			else
				tail -n1 "$v_RESULT" 2> /dev/null
				v_STATUS="$?"
				if [[ ! -e "$v_RESULT" || ! -r "$v_RESULT" || "$v_STATUS" == 1 ]]; then
					unset v_RESULT
				fi
			fi
		elif [[ "${v_RESULT:0:1}" != "/" ]]; then
			unset v_RESULT
		fi
	else
		unset v_RESULT
	fi
}

function fn_convert_seconds {
### I really haven't wrapped my head around how this function I stole works, but it converts a number of seconds to hours, minutes, and seconds.
	fn_debug "fn_convert_seconds"
	((h=${1}/3600))
	### This is the part where it does some stuff.
	((m=(${1}%3600)/60))
	((s=${1}%60))
	### I'm really excited about this part here that does the thing.
	printf "%02d:%02d:%02d\n" "$h" "$m" "$s"
}

function fn_start_script {
	fn_debug "fn_start_script"
	f_CONF="$d_PROGRAM"/lwmon.conf
	source "$d_PROGRAM"/includes/variables.shf
	fn_read_master_conf
	### Specify the working directory; create it if not present; specify the log file
	d_WORKING="$d_PROGRAM"/".lwmon"
	mkdir -p "$d_WORKING"
	v_CHILD_SCRIPT="$d_PROGRAM"/scripts/lwmon_child.sh

	### find the newst version of curl
	### /usr/bin/curl is the standard installation of curl
	### /opt/curlssl/bin/curl is where cPanel keeps the version of curl that PHP works with, which is usually the most up to date
	v_CURL_BIN=$( echo -e "$( /opt/curlssl/bin/curl --version 2> /dev/null | head -n1 | awk '{print $2}' ) /opt/curlssl/bin/curl\n$( /usr/bin/curl --version 2> /dev/null | head -n1 | awk '{print $2}' ) /usr/bin/curl\n$( $( which curl ) --version 2> /dev/null | head -n1 | awk '{print $2}' ) $( which curl )" | sort -n | grep -E "^[0-9]+\.[0-9]+" | tail -n1 | awk '{print $2}' )
	if [[ -z "$v_CURL_BIN" || "$v_USE_WGET" == "true" ]]; then
		fn_use_wget
	else
		v_CURL_BIN_VERSION="$( "$v_CURL_BIN" --version 2> /dev/null | head -n1 | awk '{print $2}')"
		v_WGET_BIN="false"
	fi
}

function fn_use_wget {
	fn_debug "fn_use_wget"
	v_WGET_BIN="$( which wget 2> /dev/null )"
	if [[ -z "$v_WGET_BIN" ]]; then
		echo "curl or wget needs to be installed for lwmon to perform some of its functions. Exiting."
		exit 1
	fi
	v_WGET_BIN_VERSION="$( wget --version | head -n1 | awk '{print $3}' )"
	v_CURL_BIN="false"
}

function fn_parse_server {
##### I'm sure I can do this better
### This function assumes that $1 is a URL, Domain name, or IP address. It then parses those out into the variables $v_CURL_URLa, $v_DOMAINa, $v_IP_ADDRESSa, and $v_SERVER_PORTa.
	fn_debug "fn_parse_server"
	if [[ -z $1 || "$1" == "false" ]]; then
		unset v_SERVER
		v_CURL_URLa="false"
		v_DOMAINa="false"
		v_IP_ADDRESSa="false"
		v_SERVER_PORTa="false"
		return
	fi
	local v_PASSED="$1"
	if [[ -n "$1" && -z "$v_SERVER" ]]; then
		v_SERVER="$1"
	fi
	if [[ $( echo "$v_SERVER" | grep -E -ci "^HTTP" ) -eq 0 ]]; then
	### If what's passed doesn't start with http or https, we can straight away assume that it's on port 80
		v_DOMAINa="$v_SERVER"
		v_CURL_URLa="$v_SERVER"
		v_SERVER_PORTa="80"
	else
		### For the domain, get rid of "http(s)" at the beginning
		v_DOMAINa="$( echo "$v_SERVER" | sed -e "s/^[Hh][Tt][Tt][Pp][Ss]*:\/\///" )"
		if [[ $( echo "$v_SERVER "| grep -E -ci "^HTTPS" ) -eq 1 ]]; then
		### If it starts with https, assume port 443 and don't strip out the protocol from the URL
			v_CURL_URLa="$v_SERVER"
			v_SERVER_PORTa="443"
		else
		### Otherwise assume port 80, and we don't need the protocol in the URL
			v_CURL_URLa="$( echo "$v_SERVER" | sed -e "s/^[Hh][Tt][Tt][Pp]:\/\///" )"
			v_SERVER_PORTa="80"
		fi
	fi
	unset v_SERVER
	### At this point in the script, we have the beginnings of a domain, a curl URL and a port
	### for the domain: get rid of the slash and anything else that follows the domain name
	v_DOMAINa="$( echo "$v_DOMAINa" | sed 's/^\([^/]*\).*$/\1/' )"
	v_DOMAINa="$( echo "$v_DOMAINa" | sed 's/[\xef\xbb\xbf]//g' )" ### <- Apparently billing is sometimes throwing special characters when you copy.
	### If the domain contains a closing square bracket followed by a colon, then numbers, then the end of the string, it's likely an ipv6 address with a port on the end
	if [[ $( echo "$v_DOMAINa" | grep -E -c "]:[0-9]+$" ) -ne 0 ]]; then
		v_SERVER_PORTa="$( echo "$v_DOMAINa" | sed "s/^.*]:\([0-9][0-9]*\)$/\1/" )"
		v_DOMAINa="$( echo "$v_DOMAINa" | sed "s/^\[*\(.*\)]:[0-9][0-9]*$/\1/" )"
	### Note: the regex here only covers IPv6 addresses.
	elif [[ $( echo "$v_DOMAINa" | grep -E -c ":[0-9]+$" ) -ne 0 && $( echo "$v_DOMAINa" | grep -E -c "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$" ) -eq 0 ]]; then
	### If it doesn't match the above but it contains a colon, then numbers, then the end of the string, but is not a valid IPv6 address...
		v_SERVER_PORTa="$( echo "$v_DOMAINa" | sed "s/^.*:\([0-9][0-9]*\)$/\1/" )"
		v_DOMAINa="$( echo "$v_DOMAINa" | sed "s/^\(.*\):[0-9][0-9]*$/\1/" )"
	fi
	### check if it's an IP. The following should match all IPv4 and IPv6 addresses
	if [[ $( echo "$v_DOMAINa" | grep -E -c "^((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$" ) -eq 0 ]]; then
	### If it doesn't look like an IP address, let's find out what the IP address REALLY is
		### Let's start by checking the hosts file
		v_DOMAINa_EGREP_SAFE="$( echo "$v_DOMAINa" | sed 's/[]\.|$(){}?+*^]/\\&/g' )"
		if [[ $( sed "s/#.*$//" /etc/hosts | grep -E -c "[[:blank:]]$v_DOMAINa_EGREP_SAFE([[:blank:]]|$)" ) -gt 0 ]]; then
			v_IP_ADDRESSa="$( sed "s/#.*$//" /etc/hosts | grep -E "[[:blank:]]$v_DOMAINa_EGREP_SAFE([[:blank:]]|$)" | tail -n1 | awk '{print $1}' )"
		else
		### If it's not there, we'll dig for it.
			v_IP_ADDRESSa="$( dig +short "$v_DOMAINa" | sort -n | tail -n1 )"
		fi
		### If the result is empty, or doesn't match IPv4 or IPv6 addresses...
		if [[ -z "$v_IP_ADDRESSa" || $( echo "$v_IP_ADDRESSa" | grep -E -c "^((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$" ) -eq 0 ]]; then
			v_IP_ADDRESSa=false
		fi
	else
		v_IP_ADDRESSa="$v_DOMAINa"
	fi
	### If there was a port specified at the command line, let's use that.
	if [[ -n "$v_CL_PORT" ]]; then
		v_SERVER_PORTa="$v_CL_PORT"
	elif [[ "$v_RUN_TYPE" == "--ssh-load" ]]; then
		v_SERVER_PORTa="22"
	fi
	### The line below can be uncommented to test this function.
	# echo -e "PASSED:     $v_PASSED\nCURL_URL:   $v_CURL_URLa\nDOMAIN:     $v_DOMAINa\nIP_ADDRESS: $v_IP_ADDRESSa\nPORT:       $v_SERVER_PORTa\n"; exit
}

function fn_check_mail_binary {
	### Check to see if an alternate mail binary has been set
	fn_debug "fn_check_mail_binary"
	a_MAIL_BIN=()
	for word in $( echo "$v_ALT_MAIL" ); do
		a_ALT_MAIL[${#a_ALT_MAIL[@]}]="$word"
	done
	unset v_ALT_MAIL
	if [[ -z ${a_ALT_MAIL[0]} || ! -x "${a_ALT_MAIL[0]}" ]]; then
		unset a_ALT_MAIL
		if [[ -z $( which mail 2> /dev/null ) ]]; then
			v_SEND_MAIL=false
		else
			v_SEND_MAIL=true
			a_MAIL_BIN=( "$( which mail 2> /dev/null )" )
		fi
	else
		v_SEND_MAIL=true
		##### I'm sure that I've tested to verify that this works... but I want to double check those tests. Might be better to just use eval.
		##### And if that's the case, is this function actually even necessary anymore?
		a_MAIL_BIN=( "${a_ALT_MAIL[@]}" )
	fi
}

function fn_make_params {
	fn_debug "fn_make_params"
	if [[ -n "$1" ]]; then
		local f_JOB="$1"
	else
		return
	fi
	echo "JOB_TYPE = $v_JOB_TYPE" > "$f_JOB"
	if [[ -n "$v_IDENT" ]]; then
		v_ORIG_JOB_NAME="$v_ORIG_JOB_NAME $v_IDENT"
		unset v_IDENT
	fi
	if [[ -z "$v_JOB_NAME" ]]; then
		v_JOB_NAME="$v_ORIG_JOB_NAME"
	fi
	echo "JOB_NAME = $v_JOB_NAME" >> "$f_JOB"
	echo "ORIG_JOB_NAME = $v_ORIG_JOB_NAME" >> "$f_JOB"

	if [[ "$v_JOB_TYPE" == "url" ]]; then
		echo "CURL_URL = $v_CURL_URL_PREEDIT" >> "$f_JOB"
		i=0; while [[ $i -le $(( ${#a_CURL_STRING[@]} -1 )) ]]; do
			### The sed at the end of this line should make the string egrep safe (which is good, because egrepping with it is exactly what we're going to do).
			echo "CURL_STRING = ${a_CURL_STRING[$i]}" >> "$f_JOB"
			i=$(( $i + 1 ))
		done
		if [[ -z "$v_USER_AGENT" ]]; then
			echo "#USER_AGENT = $v_MASTER_USER_AGENT" >> "$f_JOB"
		else
			echo "USER_AGENT = $v_USER_AGENT" >> "$f_JOB"
		fi
		if [[ "$v_IP_ADDRESS" != "false" ]]; then
			echo "IP_ADDRESS = $v_IP_ADDRESS" >> "$f_JOB"
		else
			echo "#IP_ADDRESS = " >> "$f_JOB"
		fi
		if [[ -z "$v_USE_WGET" ]]; then
			echo "#USE_WGET = $v_MASTER_USE_WGET" >> "$f_JOB"
		else
			echo "USE_WGET = $v_USE_WGET" >> "$f_JOB"
		fi
		if [[ "$v_USE_WGET" == "true" ]]; then
			v_CURL_VERBOSE="false"
			v_LOG_HTTP_CODE="false"
		fi
		if [[ -z "$v_CURL_VERBOSE" ]]; then
			echo "#CURL_VERBOSE = $v_MASTER_CURL_VERBOSE" >> "$f_JOB"
		else
			echo "CURL_VERBOSE = $v_CURL_VERBOSE" >> "$f_JOB"
		fi
		if [[ -z "$v_LOG_HTTP_CODE" ]]; then
			echo "#LOG_HTTP_CODE = $v_MASTER_LOG_HTTP_CODE" >> "$f_JOB"
		else
			echo "LOG_HTTP_CODE = $v_LOG_HTTP_CODE" >> "$f_JOB"
		fi
	elif [[ "$v_JOB_TYPE" == "dns" ]]; then
		echo "DNS_CHECK_DOMAIN = $v_DNS_CHECK_DOMAIN" >> "$f_JOB"
		if [[ -n "$v_DNS_CHECK_RESULT" ]]; then
			echo "DNS_CHECK_RESULT = $v_DNS_CHECK_RESULT" >> "$f_JOB"
		else
			echo "#DNS_CHECK_RESULT = " >> "$f_JOB"
		fi
		if [[ -z "$v_DNS_RECORD_TYPE" ]]; then
			echo "#DNS_RECORD_TYPE = $v_MASTER_DNS_RECORD_TYPE" >> "$f_JOB"
		else
			echo "DNS_RECORD_TYPE = $v_DNS_RECORD_TYPE" >> "$f_JOB"
		fi
	elif [[ "$v_JOB_TYPE" == "ssh-load" ]]; then
		if [[ -z "$v_SERVER_PORT" ]]; then
			echo "#SERVER_PORT = $v_MASTER_SERVER_PORT" >> "$f_JOB"
		else
			echo "SERVER_PORT = $v_SERVER_PORT" >> "$f_JOB"
		fi
		echo "SSH_USER = $v_SSH_USER" >> "$f_JOB"
		if [[ -z "$v_MIN_LOAD_PARTIAL_SUCCESS_PREEDIT" ]]; then
			echo "#MIN_LOAD_PARTIAL_SUCCESS = $v_MASTER_MIN_LOAD_PARTIAL_SUCCESS" >> "$f_JOB"
		else
			echo "MIN_LOAD_PARTIAL_SUCCESS = $v_MIN_LOAD_PARTIAL_SUCCESS_PREEDIT" >> "$f_JOB"
		fi
		if [[ -z "$v_MIN_LOAD_FAILURE" ]]; then
			echo "#MIN_LOAD_FAILURE = $v_MASTER_MIN_LOAD_FAILURE" >> "$f_JOB"
		else
			echo "MIN_LOAD_FAILURE = $v_MIN_LOAD_FAILURE_PREEDIT" >> "$f_JOB"
		fi
	fi


	if [[ "$v_JOB_TYPE" == "url" || "$v_JOB_TYPE" == "ssh-load" ]]; then
		if [[ -z "$v_CHECK_TIME_PARTIAL_SUCCESS" ]]; then
			echo "#CHECK_TIME_PARTIAL_SUCCESS = $v_MASTER_CHECK_TIME_PARTIAL_SUCCESS" >> "$f_JOB"
		else
			echo "CHECK_TIME_PARTIAL_SUCCESS = $v_CHECK_TIME_PARTIAL_SUCCESS_PREEDIT" >> "$f_JOB"
		fi
		if [[ -z "$v_CHECK_TIMEOUT" ]]; then
			echo "#CHECK_TIMEOUT = $v_MASTER_CHECK_TIMEOUT" >> "$f_JOB"
		else
			echo "CHECK_TIMEOUT = $v_CHECK_TIMEOUT" >> "$f_JOB"
		fi
	fi
	if [[ "$v_JOB_TYPE" == "ping" || "$v_JOB_TYPE" == "dns" || "$v_JOB_TYPE" == "ssh-load" ]]; then
		echo "DOMAIN = $v_DOMAIN" >> "$f_JOB"
	fi
	if [[ -z "$v_WAIT_SECONDS" ]]; then
		echo "#WAIT_SECONDS = $v_MASTER_WAIT_SECONDS" >> "$f_JOB"
	else
		echo "WAIT_SECONDS = $v_WAIT_SECONDS" >> "$f_JOB"
	fi
	if [[ -z "$v_EMAIL_ADDRESS" ]]; then
		echo "#EMAIL_ADDRESS = $v_MASTER_EMAIL_ADDRESS" >> "$f_JOB"
	else
		echo "EMAIL_ADDRESS = $v_EMAIL_ADDRESS" >> "$f_JOB"
	fi
	if [[ -z "$v_MAIL_DELAY" ]]; then
		echo "#MAIL_DELAY = $v_MASTER_MAIL_DELAY" >> "$f_JOB"
	else
		echo "MAIL_DELAY = $v_MAIL_DELAY" >> "$f_JOB"
	fi
	if [[ -z "$v_VERBOSITY" ]]; then
		echo "#VERBOSITY = $v_MASTER_VERBOSITY" >> "$f_JOB"
	else
		echo "VERBOSITY = $v_VERBOSITY" >> "$f_JOB"
	fi
	if [[ -z "$v_OUTPUT_FILE" ]]; then
		echo "#OUTPUT_FILE = $v_MASTER_OUTPUT_FILE" >> "$f_JOB"
	else
		echo "OUTPUT_FILE = $v_OUTPUT_FILE" >> "$f_JOB"
	fi
	if [[ -z "$v_CUSTOM_MESSAGE" ]]; then
		echo "#CUSTOM_MESSAGE = $v_MASTER_CUSTOM_MESSAGE" >> "$f_JOB"
	else
		echo "CUSTOM_MESSAGE = $v_CUSTOM_MESSAGE" >> "$f_JOB"
	fi
	if [[ -z "$v_LOG_DURATION_DATA" ]]; then
		echo "#LOG_DURATION_DATA = $v_MASTER_LOG_DURATION_DATA" >> "$f_JOB"
	else
		echo "LOG_DURATION_DATA = $v_LOG_DURATION_DATA" >> "$f_JOB"
	fi
	if [[ -z "$v_NUM_DURATIONS_RECENT" ]]; then
		echo "#NUM_DURATIONS_RECENT = $v_MASTER_NUM_DURATIONS_RECENT" >> "$f_JOB"
	else
		echo "NUM_DURATIONS_RECENT = $v_NUM_DURATIONS_RECENT" >> "$f_JOB"
	fi
	if [[ -z "$v_NUM_STATUSES_RECENT" ]]; then
		echo "#NUM_STATUSES_RECENT = $v_MASTER_NUM_STATUSES_RECENT" >> "$f_JOB"
	else
		echo "NUM_STATUSES_RECENT = $v_NUM_STATUSES_RECENT" >> "$f_JOB"
	fi
	if [[ -z "$v_NUM_STATUSES_NOT_SUCCESS" ]]; then
		echo "#NUM_STATUSES_NOT_SUCCESS = $v_MASTER_NUM_STATUSES_NOT_SUCCESS" >> "$f_JOB"
	else
		echo "NUM_STATUSES_NOT_SUCCESS = $v_NUM_STATUSES_NOT_SUCCESS" >> "$f_JOB"
	fi
	if [[ -z "$v_SCRIPT" ]]; then
		echo "#SCRIPT = " >> "$f_JOB"
	else
		echo "SCRIPT = $v_SCRIPT" >> "$f_JOB"
	fi
}
