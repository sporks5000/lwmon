#! /bin/bash

function fn_set_defaults {
	v_DEFAULT_CURL_VERBOSE="true"
	v_DEFAULT_LOG_HTTP_CODE="true"
	v_DEFAULT_DNS_RECORD_TYPE="A"
	v_DEFAULT_CHECK_TIME_PARTIAL_SUCCESS="7"
	v_DEFAULT_CHECK_TIMEOUT="10"
	v_DEFAULT_WAIT_SECONDS="30"
	v_DEFAULT_MAIL_DELAY="2"
	v_DEFAULT_VERBOSITY="standard"
	v_DEFAULT_OUTPUT_FILE="/dev/stdout"
	v_DEFAULT_LOG_DURATION_DATA="true"
	v_DEFAULT_NUM_DURATIONS_RECENT="10"
	v_DEFAULT_NUM_STATUSES_RECENT="12"
	v_DEFAULT_NUM_STATUSES_NOT_SUCCESS="3"
	v_DEFAULT_HTML_FILES_KEPT="100"
	v_DEFAULT_USE_WGET="false"
	v_DEFAULT_USER_AGENT="false"
	v_DEFAULT_SERVER_PORT="22"
	v_DEFAULT_MIN_LOAD_PARTIAL_SUCCESS="4"
	v_DEFAULT_MIN_LOAD_FAILURE="8"
	v_DEFAULT_SSH_CONTROL_PATH="~/.ssh/control:%h:%p:%r"
	v_DEFAULT_REMOTE_DIE_LIST="http://lwmon.com/die_list.txt"
	v_DEFAULT_LOG="$d_PROGRAM"/"lwmon.log"
	v_DEFAULT_ALT_MAIL=""
	v_DEFAULT_COLOR_SUCCESS=""
	v_DEFAULT_COLOR_FIRST_SUCCESS="\e[1;32m"
	v_DEFAULT_COLOR_FAILURE="\e[1;33m"
	v_DEFAULT_COLOR_FIRST_FAILURE="\e[1;31m"
	v_DEFAULT_COLOR_PARTIAL_SUCCESS="\e[1;34m"
	v_DEFAULT_COLOR_FIRST_PARTIAL_SUCCESS="\e[1;34m"
	v_DEFAULT_RETURN_SUCCESS=""
	v_DEFAULT_RETURN_FIRST_SUCCESS="\e[00m"
	v_DEFAULT_RETURN_FAILURE="\e[00m"
	v_DEFAULT_RETURN_FIRST_FAILURE="\e[00m"
	v_DEFAULT_RETURN_PARTIAL_SUCCESS="\e[00m"
	v_DEFAULT_RETURN_FIRST_PARTIAL_SUCCESS="\e[00m"
}

function fn_read_conf {
	### This function reads an item from the conf file. It expects $1 to be the name of the directive, $2 to be the name of the configuration file (or "master' or "child"), and $3 to be the result if nothing is pulled from the conf. If $4 has the value of "multi" then all instances of $1 in the conf will be assigned to an array.
	unset v_RESULT a_RESULT
	### The pattern being searched for in the conf is:
	### ^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*
	### The start of the line, followed by any number of blank characters, followed by the directive that we're looking for, followed by any number of blank characters, followed by an equal sign, followed by any number of blank characters, followed by at least one non-blank character.
	if [[ "$2" == "child" && -f "$d_WORKING"/"$v_CHILD_PID"/params ]]; then
		if [[ "$( stat --format=%Y "$d_WORKING"/"$v_CHILD_PID"/params )" -gt "$v_CHILD_CONF_STAT" ]]; then
		### Only re-read the conf file if there have been changes to it.
			v_CHILD_CONF_STAT="$( stat --format=%Y "$d_WORKING"/"$v_CHILD_PID"/params )"
			v_CHILD_CONF="$( grep -E -v "^[[:blank:]]*(#|$)" "$d_WORKING"/"$v_CHILD_PID"/params | xxd -p | tr -d '\n' )"
		fi
		if [[ "$4" == "multi" ]]; then
			i=0; while [[ $i -lt $( echo -n "$v_CHILD_CONF" | xxd -r -p | grep -E -c "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" ) ]]; do
				a_RESULT[$i]="$( echo -n "$v_CHILD_CONF" | xxd -r -p | grep -E "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" | sed -n "$(( $i + 1 )) p" | sed "s/^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*//;s/[[:blank:]]*$//" )"
				i=$(( $i + 1 ))
			done
		else
			v_RESULT="$( echo -n "$v_CHILD_CONF" | xxd -r -p | grep -E "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" | tail -n1 | sed "s/^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*//;s/[[:blank:]]*$//" )"
		fi
	elif [[ "$2" == "master" && -f "$f_CONF" ]]; then
		if [[ "$( stat --format=%Y "$f_CONF" )" -gt "$v_MASTER_CONF_STAT" ]]; then
		### Only re-read the conf file if there have been changes to it.
			v_MASTER_CONF_STAT="$( stat --format=%Y "$f_CONF" )"
			v_MASTER_CONF="$( grep -E -v "^[[:blank:]]*(#|$)" "$f_CONF" | xxd -p | tr -d '\n' )"
		fi
		if [[ "$4" == "multi" ]]; then
			i=0; while [[ $i -lt $( echo -n "$v_MASTER_CONF" | xxd -r -p | grep -E -c "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" ) ]]; do
				a_RESULT[$i]="$( echo -n "$v_MASTER_CONF" | xxd -r -p | grep -E "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" | sed -n "$(( $i + 1 )) p" | sed "s/^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*//;s/[[:blank:]]*$//" )"
				i=$(( $i + 1 ))
			done
		else
			v_RESULT="$( echo -n "$v_MASTER_CONF" | xxd -r -p | grep -E "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" | tail -n1 | sed "s/^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*//;s/[[:blank:]]*$//" )"
		fi
	elif [[ -f "$2" && "$4" == "multi" ]]; then
		i=0; while [[ $i -lt $( grep -E -c "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" "$2" 2> /dev/null) ]]; do
			a_RESULT[$i]="$( grep -E "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" "$2" 2> /dev/null) | sed -n "$(( $i + 1 )) p" | sed "s/^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*//;s/[[:blank:]]*$//" )"
			i=$(( $i + 1 ))
		done
	elif [[ -f "$2" ]]; then
		v_RESULT="$( grep -E "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*[^[:blank:]][^[:blank:]]*" "$2" 2> /dev/null | tail -n1 | sed "s/^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*//;s/[[:blank:]]*$//" )"
	fi
	if [[ -z "${a_RESULT[@]}" && -n "$3" && "$4" == "multi" ]]; then
		a_RESULT[0]="$3"
	elif [[ -z "$v_RESULT" && -n "$3" ]]; then
		v_RESULT="$3"
	fi
}

function fn_update_conf {
	### This function updates a value in the conf file. It expects $1 to be the name of the directive, $2 to be the new value for that directive, and $3 to be the name of the conf file.
	if [[ "$3" == "child" && -f "$d_WORKING"/"$v_CHILD_PID"/params ]]; then
		v_CONF_FILE="$d_WORKING"/"$v_CHILD_PID"/params
	elif [[ "$3" == "master" && -f "$f_CONF" ]]; then
		v_CONF_FILE="$f_CONF"
	else
		v_CONF_FILE="$3"
	fi
	if [[ -f "$v_CONF_FILE" ]]; then
		### We're about to run $2 through sed, so it needs to have all of its slashes escaped.
		v_MODIFIED_2="$( echo "$2" | sed -e 's/[\/&]/\\&/g' )"
		if [[ $( grep -E -c "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*" "$v_CONF_FILE" 2> /dev/null ) -gt 0 ]]; then
			sed -i "$( grep -E -n "^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*" "$v_CONF_FILE" | tail -n1 | cut -d ":" -f1 )""s/\(^[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*\).*$/\1""$v_MODIFIED_2/" "$v_CONF_FILE"
		elif [[ $( grep -E -c "^[[:blank:]]*##*[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*$" "$v_CONF_FILE" 2> /dev/null ) -gt 0 ]]; then
		### If there's a commended-out line, but it doesn't have a value afterward...
			sed -i "$( grep -E -n "^[[:blank:]]*##*[[:blank:]]*$1[[:blank:]]*=[[:blank:]]*" "$v_CONF_FILE" | tail -n1 | cut -d ":" -f1 )""s/^[[:blank:]]*##*\([[:blank:]]*$1[[:blank:]]*=[[:blank:]]*\).*$/\1""$v_MODIFIED_2/" "$v_CONF_FILE"
		else
			echo "$1 = $v_MODIFIED_2" >> "$v_CONF_FILE"
		fi
	fi
}

function fn_test_variable {
	### This function assumes that $1 is the variable in question $2 is "true" or "false" whether it needs to be a number, $3 is "false" if the variable cannot be pulled from the main config, and the directive name within the main config if it can be pulled from the main config, and $4 is what it should be set to if a setting is not found.
	unset v_RESULT
	if [[ "$3" != "false" && ( -z "$1" || "$1" == "default" || ( "$2" == true && $( echo "$1" | grep -E -c "[^0-9.]" ) -gt 0 ) ) ]]; then
		fn_read_conf "$3" master; v_RESULT="$v_RESULT"
	else
		v_RESULT="$1"
	fi
	if [[ -z "$v_RESULT" || "$v_RESULT" == "default" || ( "$2" == true && $( echo "$1" | grep -E -c "[^0-9.]" ) -gt 0 ) ]]; then
		v_RESULT="$4"
	fi
}

function fn_test_file {
	### This function expects $1 to be the path to a file, $2 to be true or false whether the file needs to be tested for read permission, and $3 to be true or false whether the file needs to be tested for write permission.
	v_RESULT="$1"
	if [[ -n "$v_RESULT" ]]; then 
		if [[ -n "$HOME" && "${v_RESULT:0:2}" == "~/" ]]; then
			v_RESULT="$HOME""${v_RESULT:1}"
		fi
		if [[ ${v_RESULT:0:1} == "/" && "$3" == true && "$2" != true ]]; then
			touch "$v_RESULT" 2> /dev/null
			v_STATUS="$?"
			if [[ ! -e "$v_RESULT" || ! -w "$v_RESULT" || "$v_STATUS" == 1 ]]; then
				unset v_RESULT
			fi
		elif [[ "${v_RESULT:0:1}" == "/" && "$3" != true && "$2" == true ]]; then
			tail -n1 "$v_RESULT" 2> /dev/null
			v_STATUS="$?"
			if [[ ! -e "$v_RESULT" || ! -r "$v_RESULT" || "$v_STATUS" == 1 ]]; then
				unset v_RESULT
			fi
		elif [[ "${v_RESULT:0:1}" == "/" && "$3" == true && "$2" == true ]]; then
			touch "$v_RESULT" 2> /dev/null
			v_STATUS="$?"
			if [[ ! -e "$v_RESULT" || ! -w "$v_RESULT" || "$v_STATUS" == 1 ]]; then
				unset v_RESULT
			else
				tail -n1 "$v_RESULT" 2> /dev/null
				v_STATUS="$?"
				if [[ ! -e "$v_RESULT" || ! -r "$v_RESULT" || "$v_STATUS" == 1 ]]; then
					unset v_RESULT
				fi
			fi
		elif [[ "${v_RESULT:0:1}" != "/" ]]; then
			unset v_RESULT
		fi
	else
		unset v_RESULT
	fi
}

function fn_convert_seconds {
### I really haven't wrapped my head around how this function I stole works, but it converts a number of seconds to hours, minutes, and seconds.
	((h=${1}/3600))
	### This is the part where it does some stuff.
	((m=(${1}%3600)/60))
	((s=${1}%60))
	### I'm really excited about this part here that does the thing.
	printf "%02d:%02d:%02d\n" "$h" "$m" "$s"
}

function fn_start_script {
	fn_set_defaults
	### Specify the working directory; create it if not present; specify the log file
	d_WORKING="$d_PROGRAM"/".lwmon"
	fn_read_conf LOG master "$v_DEFAULT_LOG"; v_LOG="$v_RESULT"
	mkdir -p "$d_WORKING"
	v_CHILD_SCRIPT="$d_PROGRAM"/scripts/lwmon_child.sh
	f_CONF="$d_PROGRAM"/lwmon.conf

	### find the newst version of curl
	### /usr/bin/curl is the standard installation of curl
	### /opt/curlssl/bin/curl is where cPanel keeps the version of curl that PHP works with, which is usually the most up to date
	v_CURL_BIN=$( echo -e "$( /opt/curlssl/bin/curl --version 2> /dev/null | head -n1 | awk '{print $2}' ) /opt/curlssl/bin/curl\n$( /usr/bin/curl --version 2> /dev/null | head -n1 | awk '{print $2}' ) /usr/bin/curl\n$( $( which curl ) --version 2> /dev/null | head -n1 | awk '{print $2}' ) $( which curl )" | sort -n | grep -E "^[0-9]+\.[0-9]+" | tail -n1 | awk '{print $2}' )
	fn_read_conf USE_WGET master "$v_DEFAULT_USE_WGET"; v_USE_WGET="$v_RESULT"
	if [[ -z "$v_CURL_BIN" || "$v_USE_WGET" == "true" ]]; then
		fn_use_wget
	else
		v_CURL_BIN_VERSION="$( "$v_CURL_BIN" --version 2> /dev/null | head -n1 | awk '{print $2}')"
		v_WGET_BIN="false"
	fi
}

function fn_use_wget {
	v_WGET_BIN="$( which wget 2> /dev/null )"
	if [[ -z "$v_WGET_BIN" ]]; then
		echo "curl or wget needs to be installed for lwmon to perform some of its functions. Exiting."
		exit 1
	fi
	v_WGET_BIN_VERSION="$( wget --version | head -n1 | awk '{print $3}' )"
	v_CURL_BIN="false"
}

function fn_parse_server {
### This function assumes that $1 is a URL, Domain name, or IP address. It then parses those out into the variables $v_CURL_URLa, $v_DOMAINa, $v_IP_ADDRESSa, and $v_SERVER_PORTa.
	if [[ -z $1 || "$1" == "false" ]]; then
		unset v_SERVER
		v_CURL_URLa="false"
		v_DOMAINa="false"
		v_IP_ADDRESSa="false"
		v_SERVER_PORTa="false"
		return
	fi
	local v_PASSED="$1"
	if [[ -n "$1" && -z "$v_SERVER" ]]; then
		v_SERVER="$1"
	fi
	if [[ $( echo "$v_SERVER" | grep -E -ci "^HTTP" ) -eq 0 ]]; then
	### If what's passed doesn't start with http or https, we can straight away assume that it's on port 80
		v_DOMAINa="$v_SERVER"
		v_CURL_URLa="$v_SERVER"
		v_SERVER_PORTa="80"
	else
		### For the domain, get rid of "http(s)" at the beginning
		v_DOMAINa="$( echo "$v_SERVER" | sed -e "s/^[Hh][Tt][Tt][Pp][Ss]*:\/\///" )"
		if [[ $( echo "$v_SERVER "| grep -E -ci "^HTTPS" ) -eq 1 ]]; then
		### If it starts with https, assume port 443 and don't strip out the protocol from the URL
			v_CURL_URLa="$v_SERVER"
			v_SERVER_PORTa="443"
		else
		### Otherwise assume port 80, and we don't need the protocol in the URL
			v_CURL_URLa="$( echo "$v_SERVER" | sed -e "s/^[Hh][Tt][Tt][Pp]:\/\///" )"
			v_SERVER_PORTa="80"
		fi
	fi
	unset v_SERVER
	### At this point in the script, we have the beginnings of a domain, a curl URL and a port
	### for the domain: get rid of the slash and anything else that follows the domain name
	v_DOMAINa="$( echo "$v_DOMAINa" | sed 's/^\([^/]*\).*$/\1/' )"
	v_DOMAINa="$( echo "$v_DOMAINa" | sed 's/[\xef\xbb\xbf]//g' )" ### <- Apparently billing is sometimes throwing special characters when you copy.
	### If the domain contains a closing square bracket followed by a colon, then numbers, then the end of the string, it's likely an ipv6 address with a port on the end
	if [[ $( echo "$v_DOMAINa" | grep -E -c "]:[0-9]+$" ) -ne 0 ]]; then
		v_SERVER_PORTa="$( echo "$v_DOMAINa" | sed "s/^.*]:\([0-9][0-9]*\)$/\1/" )"
		v_DOMAINa="$( echo "$v_DOMAINa" | sed "s/^\[*\(.*\)]:[0-9][0-9]*$/\1/" )"
	### Note: the regex here only covers IPv6 addresses.
	elif [[ $( echo "$v_DOMAINa" | grep -E -c ":[0-9]+$" ) -ne 0 && $( echo "$v_DOMAINa" | grep -E -c "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$" ) -eq 0 ]]; then
	### If it doesn't match the above but it contains a colon, then numbers, then the end of the string, but is not a valid IPv6 address...
		v_SERVER_PORTa="$( echo "$v_DOMAINa" | sed "s/^.*:\([0-9][0-9]*\)$/\1/" )"
		v_DOMAINa="$( echo "$v_DOMAINa" | sed "s/^\(.*\):[0-9][0-9]*$/\1/" )"
	fi
	### check if it's an IP. The following should match all IPv4 and IPv6 addresses
	if [[ $( echo "$v_DOMAINa" | grep -E -c "^((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$" ) -eq 0 ]]; then
	### If it doesn't look like an IP address, let's find out what the IP address REALLY is
		### Let's start by checking the hosts file
		v_DOMAINa_EGREP_SAFE="$( echo "$v_DOMAINa" | sed 's/[]\.|$(){}?+*^]/\\&/g' )"
		if [[ $( sed "s/#.*$//" /etc/hosts | grep -E -c "[[:blank:]]$v_DOMAINa_EGREP_SAFE([[:blank:]]|$)" ) -gt 0 ]]; then
			v_IP_ADDRESSa="$( sed "s/#.*$//" /etc/hosts | grep -E "[[:blank:]]$v_DOMAINa_EGREP_SAFE([[:blank:]]|$)" | tail -n1 | awk '{print $1}' )"
		else
		### If it's not there, we'll dig for it.
			v_IP_ADDRESSa="$( dig +short "$v_DOMAINa" | sort -n | tail -n1 )"
		fi
		### If the result is empty, or doesn't match IPv4 or IPv6 addresses...
		if [[ -z "$v_IP_ADDRESSa" || $( echo "$v_IP_ADDRESSa" | grep -E -c "^((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$" ) -eq 0 ]]; then
			v_IP_ADDRESSa=false
		fi
	else
		v_IP_ADDRESSa="$v_DOMAINa"
	fi
	### If there was a port specified at the command line, let's use that.
	if [[ -n "$v_CL_PORT" ]]; then
		v_SERVER_PORTa="$v_CL_PORT"
	elif [[ "$v_RUN_TYPE" == "--ssh-load" ]]; then
		v_SERVER_PORTa="22"
	fi
	### The line below can be uncommented to test this function.
	# echo -e "PASSED:     $v_PASSED\nCURL_URL:   $v_CURL_URLa\nDOMAIN:     $v_DOMAINa\nIP_ADDRESS: $v_IP_ADDRESSa\nPORT:       $v_SERVER_PORTa\n"; exit
}

function fn_check_mail_binary {
	### Check to see if an alternate mail binary has been set
	a_MAIL_BIN=()
	fn_read_conf ALT_MAIL master; v_ALT_MAIL="$v_RESULT"
	for word in $( echo "$v_ALT_MAIL" ); do
		a_ALT_MAIL[${#a_ALT_MAIL[@]}]="$word"
	done
	unset v_ALT_MAIL
	if [[ -z ${a_ALT_MAIL[0]} || ! -x "${a_ALT_MAIL[0]}" ]]; then
		unset a_ALT_MAIL
		if [[ -z $( which mail 2> /dev/null ) ]]; then
			v_SEND_MAIL=false
		else
			v_SEND_MAIL=true
			a_MAIL_BIN=( "$( which mail 2> /dev/null )" )
		fi
	else
		v_SEND_MAIL=true
		##### I'm sure that I've tested to verify that this works... but I want to double check those tests. Might  be better to just use eval.
		a_MAIL_BIN=( "${a_ALT_MAIL[@]}" )
	fi
}
