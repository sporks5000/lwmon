#! /bin/bash

function fn_remove_unnecessary_functions {
### The only functions we need to keep are fn_read_conf, fn_check_mail_binary
	unset -f fn_set_defaults
	unset -f fn_test_variable
	unset -f fn_test_file
	unset -f fn_convert_seconds
	unset -f fn_start_script
	unset -f fn_use_wget
	unset -f fn_parse_server
	unset -f fn_locate
	unset -f fn_url_cl
	unset -f fn_ping_cl
	unset -f fn_dns_cl
	unset -f fn_load_cl
	unset -f fn_mutual_cl
	unset -f fn_list
	unset -f fn_modify_master
	unset -f fn_modify_no_master
	unset -f fn_modify_old_jobs
	unset -f fn_modify_html
	unset -f fn_modify
	unset -f fn_update_conf
	unset -f fn_parse_cl_argument
	unset -f fn_create_config
	unset -f fn_help
	unset -f fn_help_flags
	unset -f fn_help_process_types
	unset -f fn_help_params_file
	unset -f fn_help_files
	unset -f fn_version
	unset -f fn_remove_unnecessary_functions
}

function fn_master {
	### This is the loop for the master function.
	if [[ $v_RUNNING_STATE != "master" ]]; then
		echo "Master process already present. Exiting."
		exit 1
	fi
	### try to prevent the master process from exiting unexpectedly.
	trap fn_master_exit SIGINT SIGTERM SIGKILL
	fn_remove_unnecessary_functions
	fn_read_conf VERBOSITY master "$v_DEFAULT_VERBOSITY"; v_VERBOSITY="$v_RESULT"
	### Get rid of the save file (if there is one).
	if [[ -f "$d_WORKING"/save ]]; then
		rm -f "$d_WORKING"/save
	fi
	v_TIMESTAMP_FIVE_MINUTES=0
	v_TIMESTAMP_THIRTY_MINUTES=0
	if [[ "$v_WGET_BIN" == "false" ]]; then
		if [[ -n $v_DEFAULT_REMOTE_DIE_LIST ]]; then
			$v_CURL_BIN -Lsm 10 "$v_DEFAULT_REMOTE_DIE_LIST" > "$d_WORKING"/die_list 2> /dev/null
		fi
		v_REMOTE_VERSION="$( $v_CURL_BIN -Lsm 10 http://lwmon.com/lwmon.sh 2> /dev/null | head -n 10 | grep -E "^v_VERSION" | cut -d "\"" -f2 )"
	else
		if [[ -n $v_DEFAULT_REMOTE_DIE_LIST ]]; then
			$v_WGET_BIN -q --timeout=10 -O "$d_WORKING"/die_list "$v_DEFAULT_REMOTE_DIE_LIST" 2> /dev/null
		fi
		v_REMOTE_VERSION="$( $v_WGET_BIN -q --timeout=10 -O "/dev/stdout" http://lwmon.com/lwmon.sh 2> /dev/null | head -n 10 | grep -E "^v_VERSION" | cut -d "\"" -f2 )"
	fi
	##### I removed all of the old version checking routines, but I'll need to create new ones
	fn_check_mail_binary
	if [[ $v_SEND_MAIL == false ]]; then
		echo
		echo -e "\e[1;31mThe \"mail\" binary needs to be installed for lwmon to perform some of its functions. Monitoring jobs will not be able to send email allerts regarding changes of status.\e[00m"
		echo
	fi
	echo "$( date +%F" "%T" "%Z ) - [$$] - Starting the Master Process" >> "$v_LOG"
	while [[ 1 == 1 ]]; do

		### Every thirty minutes check to see what the current IP address is (thanks to VPN, this can change).
		if [[ $(( $( date +%s ) - 1800 )) -gt $v_TIMESTAMP_THIRTY_MINUTES ]]; then
			v_TIMESTAMP_THIRTY_MINUTES="$( date +%s )"
			if [[ "$v_WGET_BIN" == "false" ]]; then
				v_LOCAL_IP="$( $v_CURL_BIN -Lsm 10 http://ip.liquidweb.com/ 2> /dev/null )"
			else
				v_LOCAL_IP="$( $v_WGET_BIN -q --timeout=10 -O /dev/null http://ip.liquidweb.com/ 2> /dev/null )"
			fi
			if [[ -z $v_LOCAL_IP ]]; then
				v_LOCAL_IP="Not_Found"
			fi
			### Also, let's do getting rid of old processes here - there's no reason to do that every two seconds, and this already runs every half hour, so there's no need to create a separate timer for that.
			for v_OLD_CHILD in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "^old_[0-9]+_[0-9]+$" ); do
				if [[ $( echo $v_OLD_CHILD | grep -E -c "^old_[[:digit:]]*_[[:digit:]]*$" ) -eq 1 ]]; then
					if [[ $(( $( date +%s ) - $( echo $v_OLD_CHILD | cut -d "_" -f3 ) )) -gt 604800 ]]; then
						### 604800 seconds = seven days.
						fn_read_conf JOB_TYPE "$d_WORKING"/"$v_OLD_CHILD""/params"; v_JOB_TYPE="$v_RESULT"
						fn_read_conf JOB_NAME "$d_WORKING"/"$v_OLD_CHILD""/params"; v_JOB_NAME="$v_RESULT"
						echo "$( date +%F" "%T" "%Z ) - [$( echo "$v_OLD_CHILD" | cut -d "_" -f2)] - $v_JOB_TYPE $v_JOB_NAME - Child process dead for seven days. Deleting backed up data." >> "$v_LOG"
						rm -rf "$d_WORKING"/"$v_OLD_CHILD"
					fi
				fi
			done
		fi

		### Every five minutes, check a remote list to see if lwmon should be stopped, and check to see if old processes need to be backed up.
		if [[ $(( $( date +%s ) - 300 )) -gt $v_TIMESTAMP_FIVE_MINUTES ]]; then
			v_TIMESTAMP_FIVE_MINUTES="$( date +%s )"
			if [[ -n $v_DEFAULT_REMOTE_DIE_LIST && "$v_WGET_BIN" == "false" ]]; then
				$v_CURL_BIN -Lsm 10 "$v_DEFAULT_REMOTE_DIE_LIST" > "$d_WORKING"/die_list 2> /dev/null
			elif [[ -n $v_DEFAULT_REMOTE_DIE_LIST ]]; then
				$v_WGET_BIN -q --timeout=10 -O "$d_WORKING"/die_list "$v_DEFAULT_REMOTE_DIE_LIST" 2> /dev/null
			fi
			if [[ $( grep -E -c "^[[:blank:]]*$v_LOCAL_IP[[:blank:]]*(#.*)*$" "$d_WORKING"/die_list ) -gt 0 ]]; then
				touch "$d_WORKING"/die
				touch "$d_WORKING"/save
				echo "$( date +%F" "%T" "%Z ) - [$$] - Local IP found on remote list. The line reads \"$( grep -E "^[[:blank:]]*$v_LOCAL_IP[[:blank:]]*(#.*)*$" "$d_WORKING"/die_list | head -n1 )\". Process ended." >> "$v_LOG"
				fn_master_exit 1
			fi
			### Go through the directories for child processes. Make sure that each one is associated with a running child process. If not....
			for v_CHILD_PID in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "^[0-9]+$" ); do
				if [[ $( cat /proc/$v_CHILD_PID/cmdline 2> /dev/null | tr "\0" " " | grep -E -c "$f_PROGRAM[[:blank:]]" ) -eq 0 ]]; then
					### If it hasn't been marked to die, restart it.
					if [[ ! -f "$d_WORKING"/"$v_CHILD_PID/die" ]]; then
						fn_read_conf JOB_TYPE child; v_JOB_TYPE="$v_RESULT"
						fn_read_conf JOB_NAME child; v_JOB_NAME="$v_RESULT"
						echo "$( date +%F" "%T" "%Z ) - [$v_CHILD_PID] - $v_JOB_TYPE $v_JOB_NAME - Child process was found dead. Restarting with new PID." >> "$v_LOG"
						v_NEW_JOB="$( date +%s )""_$RANDOM.job"
						cp -a "$d_WORKING"/"$v_CHILD_PID"/params "$d_WORKING"/"new/$v_NEW_JOB.job"
						if [[ -f "$d_WORKING"/"$v_CHILD_PID"/log ]]; then
							### If there's a log file, let's keep that too.
							cp -a "$d_WORKING"/"$v_CHILD_PID"/log "$d_WORKING"/"new/$v_NEW_JOB".log
						fi
					fi
					### Regardless of whether or not it's been marked to die, back it up.
					v_TIMESTAMP="$( date +%s )"
					mv "$d_WORKING"/"$v_CHILD_PID" "$d_WORKING"/"old_""$v_CHILD_PID""_""$v_TIMESTAMP"
				fi
			done
		fi

		### Every Two Seconds, check if there are any new files within the new/ directory. Assume that they're params files for new jobs
		if [[ $( ls -1 "$d_WORKING"/new/*.job 2> /dev/null | wc -l ) -gt 0 ]]; then
		### If there are any at all, take the first one and start a job from it. The next one can wait for the next loop.
			v_LWMON_JOB="$( ls -1 "$d_WORKING"/new/*.job 2> /dev/null | head -n1 )"
			fn_read_conf JOB_TYPE "$v_LWMON_JOB"; v_JOB_TYPE="$v_RESULT"
			fn_read_conf JOB_NAME "$v_LWMON_JOB"; v_JOB_NAME="$v_RESULT"
			if [[ $v_JOB_TYPE == "url" ]]; then
				v_JOB_NAME="URL $v_JOB_NAME"
				fn_spawn_child_process
			elif [[ $v_JOB_TYPE == "ping" ]]; then
				v_JOB_NAME="PING $v_JOB_NAME"
				fn_spawn_child_process
			elif [[ $v_JOB_TYPE == "dns" ]]; then
				v_JOB_NAME="DNS $v_JOB_NAME"
				fn_spawn_child_process
			elif [[ $v_JOB_TYPE == "ssh-load" ]]; then
				v_JOB_NAME="SSH-LOAD $v_JOB_NAME"
				fn_spawn_child_process
			fi
		else
			if [[ $( ls -1 "$d_WORKING"/"new/" | wc -l ) -gt 0 ]]; then
				rm -f "$d_WORKING"/new/*
			fi
		fi
		### Is there a file named "die" in the working directory? If so, end the master process.
		if [[ -f "$d_WORKING"/die ]]; then
			fn_master_exit 0
		fi
		sleep 2
	done
}

function fn_spawn_child_process {
	### This function launches the child process and makes sure that it has it's own working directory.
	### Launch the child process
	"$v_CHILD_SCRIPT" $v_JOB_NAME &
	### Note - the job name doesn't need to be present, but it makes ps more readable. Each child process starts out as generic. Once the master process creates a working directory for it (based on its PID) and then puts the params file in place for it, only then does it discover its purpose.
	### create the child's wirectory and move the params file there.
	v_CHILD_PID=$!
	mkdir -p "$d_WORKING"/"$v_CHILD_PID"
	touch "$d_WORKING"/"$v_CHILD_PID/#die"
	mv "$v_LWMON_JOB" "$d_WORKING"/"$v_CHILD_PID""/params"
	if [[ -f "${v_LWMON_JOB[@]%.job}".log ]]; then
	### If there's a log file, let's move that log file into the appropriate directory as well.
		mv "${v_LWMON_JOB[@]%.job}".log "$d_WORKING"/"$v_CHILD_PID""/log"
	fi
}

function fn_master_exit {
	### these steps are run after the master process has recieved a signal that it needs to die. "$1" is the exit code that should be passed.
	v_EXIT_CODE="$1"
	echo "$( date +%F" "%T" "%Z ) - [$$] - Ending the Master Process" >> "$v_LOG"
	if [[ ! -f "$d_WORKING"/die && $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "." | grep -E -vc "[^0-9]" ) -gt 0 ]]; then
		### If the "die" file is not present, it was CTRL-C'd from the command line. Check if there are child processes, then prompt if they should be saved.
		### Create a no_output file
		touch "$d_WORKING"/no_output
		echo "Options:"
		echo
		echo "  1) Kill the master process and all child processes."
		echo "  2) Back up the data for the child processes so that they'll start again next time LWmon is run, then kill the master process and all child processes."
		echo
		read -t 15 -ep "How would you like to proceed? " v_OPTION_NUM
		# If they've opted to kill off all the current running processes, place a "die" file in each of their directories.
		if [[ $v_OPTION_NUM == "1" ]]; then
			for i in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "." | grep -E -v "[^0-9]" ); do
				v_CHILD_PID=$( basename $i )
				if [[ $( cat /proc/$v_CHILD_PID/cmdline 2> /dev/null | tr "\0" " " | grep -E -c "$f_PROGRAM[[:blank:]]" ) -gt 0 ]]; then
					touch "$d_WORKING"/"$v_CHILD_PID/die"
				fi
			done
		elif [[ -z $v_OPTION_NUM ]]; then
			echo
		fi
	elif [[ -f "$d_WORKING"/die && ! -f "$d_WORKING"/save ]]; then
		for i in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "." | grep -E -v "[^0-9]" ); do
			v_CHILD_PID=$( basename $i )
			if [[ $( cat /proc/$v_CHILD_PID/cmdline 2> /dev/null | tr "\0" " " | grep -E -c "$f_PROGRAM[[:blank:]]" ) -gt 0 ]]; then
				touch "$d_WORKING"/"$v_CHILD_PID/die"
			fi
		done
	fi
	rm -f "$d_WORKING"/lwmon.pid "$d_WORKING"/die
	exit $v_EXIT_CODE
}
