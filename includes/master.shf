#! /bin/bash

function fn_remove_unnecessary_functions {
### dump all of the functions that we won't need in order to keep the master process as lightweight as possible
	fn_debug "fn_remove_unnecessary_functions"
	##### Go back through and make sure that I'm getting rid of all of the functions I don't wat
	### Functions from master.shf
	unset -f fn_remove_unnecessary_functions

	### Functions from ./lwmon.sh
	unset -f fn_locate
	unset -f fn_assign_run_type
	unset -f fn_process_args
	unset -f fn_test_string
	unset -f fn_test_integer
	unset -f fn_test_float
	unset -f fn_test_child_pid
	unset -f fn_test_email
	unset -f fn_test_ip
	unset -f fn_test_flag_with_run

	### Functions from mutual.shf
	unset -f fn_update_conf
	unset -f fn_convert_seconds
	unset -f fn_start_script
	unset -f fn_use_wget
	unset -f fn_parse_server
	unset -f fn_make_params

	### functions from variables.shf
	### Functions we keep: fn_set_defaults fn_is_integer fn_is_float fn_is_boolean fn_is_file_path fn_is_email fn_is_verbosity fn_is_string fn_read_master_conf fn_read_child_params_lite
	unset -f fn_read_child_params

	### Functions from create.shf
	unset -f fn_url_cl
	unset -f fn_ping_cl
	unset -f fn_dns_cl
	unset -f fn_load_cl
	unset -f fn_mutual_cl

	### functions from create_config.shf
	unset -f fn_create_config
}

function fn_master {
	### This is the loop for the master function.
	fn_debug "fn_master"
	if [[ "$v_RUNNING_STATE" != "master" ]]; then
		echo "Master process already present. Exiting."
		exit 1
	fi
	### try to prevent the master process from exiting unexpectedly.
	trap fn_master_exit SIGINT SIGTERM SIGKILL
	fn_remove_unnecessary_functions
	v_MASTER_RELOAD="$( stat --format=%Y "$f_CONF" )"

	### Get rid of the save file and no_output file from the previous session.
	rm -f "$d_WORKING"/save "$d_WORKING"/no_output

	v_TIMESTAMP_FIVE_MINUTES=0
	v_TIMESTAMP_THIRTY_MINUTES=0
	v_TIMESTAMP_THIRTY_SECONDS=0
	if [[ "$v_WGET_BIN" == "false" ]]; then
		DONOTHING=true #####
		##### We used to check for the most up-to-date version here. need to re-impliment this
	else
		DONOTHING=true #####
		##### We used to check for the most up-to-date version here. need to re-impliment this
	fi
	##### I removed all of the old version checking routines, but I'll need to create new ones
	echo "$( date +%F" "%T" "%Z ) - [$$] - Starting the Master Process" >> "$v_LOG"
	while [[ 1 == 1 ]]; do
		local v_DATE="$( date +%s )"

		### Every thirty seconds, check if we need to re-read the master conf
		if [[ $(( v_DATE - 30 )) -gt "$v_TIMESTAMP_THIRTY_SECONDS" ]]; then
			v_TIMESTAMP_THIRTY_SECONDS="$v_DATE"
			local v_MASTER_CUR="$( stat --format=%Y "$f_CONF" )"
			if [[ "$v_MASTER_CUR" -gt "$v_MASTER_RELOAD" ]]; then
				v_MASTER_RELOAD="$v_MASTER_CUR"
				fn_read_master_conf master
			fi
		fi

		### Every thirty minutes get rid of the files for processes that ended greater than seven days ago
		if [[ $(( v_DATE - 1800 )) -gt "$v_TIMESTAMP_THIRTY_MINUTES" ]]; then
			v_TIMESTAMP_THIRTY_MINUTES="$v_DATE"
			### Also, let's do getting rid of old processes here - there's no reason to do that every two seconds, and this already runs every half hour, so there's no need to create a separate timer for that.
			for v_OLD_CHILD in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "^old_[0-9]+_[0-9]+$" ); do
				if [[ $( echo "$v_OLD_CHILD" | grep -E -c "^old_[[:digit:]]*_[[:digit:]]*$" ) -eq 1 ]]; then
					if [[ $(( v_DATE - $( echo "$v_OLD_CHILD" | cut -d "_" -f3 ) )) -gt 604800 ]]; then
						### 604800 seconds = seven days.
						fn_read_child_params_lite "$d_WORKING"/"$v_OLD_CHILD"/params
						echo "$( date +%F" "%T" "%Z ) - [$( echo "$v_OLD_CHILD" | cut -d "_" -f2)] - $v_JOB_TYPE $v_JOB_NAME - Child process dead for seven days. Deleting backed up data." >> "$v_LOG"
						rm -rf "$d_WORKING"/"$v_OLD_CHILD"
					fi
				fi
			done
		fi

		### Every five minutes, make surethat the directories for child processes are ACTUALLY associated with running child processes
		if [[ $(( v_DATE - 300 )) -gt "$v_TIMESTAMP_FIVE_MINUTES" ]]; then
			v_TIMESTAMP_FIVE_MINUTES="$v_DATE"
			### Go through the directories for child processes. Make sure that each one is associated with a running child process. If not....
			for v_CHILD_PID in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "^[0-9]+$" ); do
				if [[ $( cat /proc/$v_CHILD_PID/cmdline 2> /dev/null | tr "\0" " " | grep -E -c "lwmon_child.sh[[:blank:]]" ) -eq 0 ]]; then
					### If it hasn't been marked to die, restart it.
					if [[ ! -f "$d_WORKING"/"$v_CHILD_PID/die" ]]; then
						fn_read_child_params_lite "$d_WORKING"/"$v_CHILD_PID"/params
						echo "$( date +%F" "%T" "%Z ) - [$v_CHILD_PID] - $v_JOB_TYPE $v_JOB_NAME - Child process was found dead. Restarting with new PID." >> "$v_LOG"
						v_NEW_JOB="$v_DATE""_$RANDOM.job"
						cp -a "$d_WORKING"/"$v_CHILD_PID"/params "$d_WORKING"/"new/$v_NEW_JOB.job"
						if [[ -f "$d_WORKING"/"$v_CHILD_PID"/log ]]; then
							### If there's a log file, let's keep that too.
							cp -a "$d_WORKING"/"$v_CHILD_PID"/log "$d_WORKING"/"new/$v_NEW_JOB".log
						fi
					fi
					### Regardless of whether or not it's been marked to die, back it up.
					v_TIMESTAMP="$v_DATE"
					mv "$d_WORKING"/"$v_CHILD_PID" "$d_WORKING"/"old_""$v_CHILD_PID""_""$v_TIMESTAMP"
				fi
			done
		fi

		### Every Two Seconds, check if there are any new files within the new/ directory. Assume that they're params files for new jobs
		if [[ $( ls -1 "$d_WORKING"/new/*.job 2> /dev/null | wc -l ) -gt 0 ]]; then
		### If there are any at all, take the first one and start a job from it. The next one can wait for the next loop.
			v_LWMON_JOB="$( ls -1 "$d_WORKING"/new/*.job 2> /dev/null | head -n1 )"
			fn_read_child_params_lite "$v_LWMON_JOB"
			if [[ "$v_JOB_TYPE" == "url" ]]; then
				v_JOB_NAME="URL $v_JOB_NAME"
				fn_spawn_child_process
			elif [[ "$v_JOB_TYPE" == "ping" ]]; then
				v_JOB_NAME="PING $v_JOB_NAME"
				fn_spawn_child_process
			elif [[ "$v_JOB_TYPE" == "dns" ]]; then
				v_JOB_NAME="DNS $v_JOB_NAME"
				fn_spawn_child_process
			elif [[ "$v_JOB_TYPE" == "ssh-load" ]]; then
				v_JOB_NAME="SSH-LOAD $v_JOB_NAME"
				fn_spawn_child_process
			fi
		else
			if [[ $( ls -1 "$d_WORKING"/"new/" | wc -l ) -gt 0 ]]; then
				rm -f "$d_WORKING"/new/*
			fi
		fi

		### Is there a file named "die" in the working directory? If so, end the master process.
		if [[ -f "$d_WORKING"/die ]]; then
			fn_master_exit 0
		fi
		sleep 2
	done
}

function fn_spawn_child_process {
	### This function launches the child process and makes sure that it has it's own working directory.
	### Launch the child process
	fn_debug "fn_spawn_child_process"
	"$v_CHILD_SCRIPT" "$v_JOB_NAME" &
	### Note - the job name doesn't need to be present, but it makes ps more readable. Each child process starts out as generic. Once the master process creates a working directory for it (based on its PID) and then puts the params file in place for it, only then does it discover its purpose.
	### create the child's wirectory and move the params file there.
	v_CHILD_PID=$!
	mkdir -p "$d_WORKING"/"$v_CHILD_PID"
	touch "$d_WORKING"/"$v_CHILD_PID/#die"
	mv "$v_LWMON_JOB" "$d_WORKING"/"$v_CHILD_PID"/params
	if [[ -f "${v_LWMON_JOB[@]%.job}".log ]]; then
	### If there's a log file, let's move that log file into the appropriate directory as well.
		mv "${v_LWMON_JOB[@]%.job}".log "$d_WORKING"/"$v_CHILD_PID""/log"
	fi
}

function fn_master_exit {
	### these steps are run after the master process has recieved a signal that it needs to die. "$1" is the exit code that should be passed.
	fn_debug "fn_master_exit"
	v_EXIT_CODE="$1"
	if [[ -z "$v_EXIT_CODE" ]]; then
		v_EXIT_CODE="0"
	fi
	echo "$( date +%F" "%T" "%Z ) - [$$] - Ending the Master Process" >> "$v_LOG"
	if [[ ! -f "$d_WORKING"/die && $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "." | grep -E -vc "[^0-9]" ) -gt 0 ]]; then
		### If the "die" file is not present, it was CTRL-C'd from the command line. Check if there are child processes, then prompt if they should be saved.
		### Create a no_output file
		touch "$d_WORKING"/no_output
		echo "Options:"
		echo
		echo "  1) Kill the master process and all child processes."
		echo "  2) Back up the data for the child processes so that they'll start again next time LWmon is run, then kill the master process and all child processes."
		echo
		read -t 15 -ep "How would you like to proceed? " v_OPTION_NUM
		# If they've opted to kill off all the current running processes, place a "die" file in each of their directories.
		if [[ "$v_OPTION_NUM" == "1" ]]; then
			for i in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "." | grep -E -v "[^0-9]" ); do
				v_CHILD_PID=$( basename "$i" )
				if [[ $( cat /proc/$v_CHILD_PID/cmdline 2> /dev/null | tr "\0" " " | grep -E -c "lwmon_child.sh[[:blank:]]" ) -gt 0 ]]; then
					touch "$d_WORKING"/"$v_CHILD_PID/die"
				fi
			done
		elif [[ -z "$v_OPTION_NUM" ]]; then
			echo
		fi
	elif [[ -f "$d_WORKING"/die && ! -f "$d_WORKING"/save ]]; then
		for i in $( find "$d_WORKING"/ -maxdepth 1 -type d | rev | cut -d "/" -f1 | rev | grep -E "." | grep -E -v "[^0-9]" ); do
			v_CHILD_PID=$( basename "$i" )
			if [[ $( cat /proc/$v_CHILD_PID/cmdline 2> /dev/null | tr "\0" " " | grep -E -c "lwmon_child.sh[[:blank:]]" ) -gt 0 ]]; then
				touch "$d_WORKING"/"$v_CHILD_PID/die"
			fi
		done
	fi
	rm -f "$d_WORKING"/lwmon.pid "$d_WORKING"/die
	exit "$v_EXIT_CODE"
}
